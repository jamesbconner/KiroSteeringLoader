#!/usr/bin/env node

/**
 * Test Failure Notification System
 * 
 * This script handles notifications for test failures in CI/CD pipelines.
 * It can create GitHub issues, send notifications, or update PR comments.
 */

import fs from 'fs';
import path from 'path';

class TestFailureNotifier {
  constructor() {
    this.coverageDir = 'coverage';
    this.githubToken = process.env.GITHUB_TOKEN;
    this.githubRepository = process.env.GITHUB_REPOSITORY;
    this.githubRunId = process.env.GITHUB_RUN_ID;
    this.githubSha = process.env.GITHUB_SHA;
    this.isPullRequest = process.env.GITHUB_EVENT_NAME === 'pull_request';
    this.pullRequestNumber = process.env.GITHUB_PR_NUMBER;
  }

  /**
   * Load the latest test failure report
   */
  loadTestFailureReport() {
    const reportFiles = fs.readdirSync(this.coverageDir)
      .filter(file => file.startsWith('test-failure-report-') && file.endsWith('.json'))
      .sort()
      .reverse();

    if (reportFiles.length === 0) {
      console.log('No test failure report found.');
      return null;
    }

    const reportPath = path.join(this.coverageDir, reportFiles[0]);
    try {
      return JSON.parse(fs.readFileSync(reportPath, 'utf8'));
    } catch (error) {
      console.error(`Error loading test report: ${error.message}`);
      return null;
    }
  }

  /**
   * Generate notification message
   */
  generateNotificationMessage(report) {
    let message = `## ðŸš¨ Test Failure Notification\n\n`;
    
    message += `**Build:** [#${this.githubRunId}](https://github.com/${this.githubRepository}/actions/runs/${this.githubRunId})\n`;
    message += `**Commit:** \`${this.githubSha?.substring(0, 7)}\`\n`;
    message += `**Timestamp:** ${report.timestamp}\n\n`;

    // Summary
    message += `### Summary\n\n`;
    message += `- **Total Tests:** ${report.summary.totalTests}\n`;
    message += `- **Passed:** ${report.summary.passedTests} âœ…\n`;
    message += `- **Failed:** ${report.summary.failedTests} âŒ\n`;
    message += `- **Skipped:** ${report.summary.skippedTests} â­ï¸\n\n`;

    // Failed tests
    if (report.summary.failedTests > 0) {
      message += `### Failed Tests\n\n`;
      
      for (const suiteFailure of report.failures) {
        message += `#### ${suiteFailure.suite.charAt(0).toUpperCase() + suiteFailure.suite.slice(1)} Tests\n\n`;
        
        for (const failure of suiteFailure.failures) {
          message += `- **${failure.testName}**\n`;
          message += `  - File: \`${failure.testFile}\`\n`;
          if (failure.duration) {
            message += `  - Duration: ${failure.duration}ms\n`;
          }
          message += `  - Error: \`${failure.error.split('\\n')[0]}\`\n\n`;
        }
      }
    }

    // Coverage issues
    if (report.coverage) {
      const coverageThreshold = 85;
      const lowCoverage = [];
      
      ['lines', 'functions', 'branches', 'statements'].forEach(metric => {
        if (parseFloat(report.coverage[metric].percentage) < coverageThreshold) {
          lowCoverage.push(`${metric}: ${report.coverage[metric].percentage}%`);
        }
      });

      if (lowCoverage.length > 0) {
        message += `### âš ï¸ Coverage Issues\n\n`;
        message += `The following metrics are below the ${coverageThreshold}% threshold:\n\n`;
        lowCoverage.forEach(warning => {
          message += `- ${warning}\n`;
        });
        message += `\n`;
      }
    }

    // Performance issues
    if (report.performance) {
      message += `### Performance Metrics\n\n`;
      message += `- **Activation Time:** ${report.performance.activationTime}ms\n`;
      message += `- **Memory Usage:** ${report.performance.memoryUsage}MB\n`;
      if (report.performance.largeDatasetPerformance) {
        message += `- **Large Dataset Performance:** ${report.performance.largeDatasetPerformance}ms\n`;
      }
      message += `\n`;
    }

    message += `### Next Steps\n\n`;
    message += `1. Review the failed tests and fix the underlying issues\n`;
    message += `2. Check the full test logs in the [GitHub Actions run](https://github.com/${this.githubRepository}/actions/runs/${this.githubRunId})\n`;
    message += `3. Run tests locally to reproduce and debug failures\n`;
    message += `4. Update tests if they need to be modified due to intentional changes\n\n`;

    message += `---\n`;
    message += `*This notification was automatically generated by the test failure reporter.*`;

    return message;
  }

  /**
   * Create GitHub issue for test failures
   */
  async createGitHubIssue(report) {
    if (!this.githubToken || !this.githubRepository) {
      console.log('GitHub token or repository not available. Skipping issue creation.');
      return;
    }

    const title = `Test Failures in Build #${this.githubRunId}`;
    const body = this.generateNotificationMessage(report);

    // In a real implementation, you would use the GitHub API here
    // For now, we'll just log the issue details
    console.log('GitHub Issue would be created with:');
    console.log(`Title: ${title}`);
    console.log(`Body: ${body.substring(0, 200)}...`);
    
    // Save issue content to file for manual review
    const issueFile = path.join(this.coverageDir, `github-issue-${Date.now()}.md`);
    fs.writeFileSync(issueFile, `# ${title}\\n\\n${body}`);
    console.log(`Issue content saved to: ${issueFile}`);
  }

  /**
   * Update PR comment with test results
   */
  async updatePullRequestComment(report) {
    if (!this.isPullRequest || !this.pullRequestNumber) {
      console.log('Not a pull request. Skipping PR comment update.');
      return;
    }

    const comment = this.generateNotificationMessage(report);
    
    // In a real implementation, you would use the GitHub API here
    console.log('PR Comment would be updated with:');
    console.log(comment.substring(0, 200) + '...');
    
    // Save comment content to file for manual review
    const commentFile = path.join(this.coverageDir, `pr-comment-${Date.now()}.md`);
    fs.writeFileSync(commentFile, comment);
    console.log(`PR comment content saved to: ${commentFile}`);
  }

  /**
   * Send Slack notification (placeholder)
   */
  async sendSlackNotification(report) {
    const slackWebhook = process.env.SLACK_WEBHOOK_URL;
    
    if (!slackWebhook) {
      console.log('Slack webhook not configured. Skipping Slack notification.');
      return;
    }

    const message = {
      text: `ðŸš¨ Test failures detected in ${this.githubRepository}`,
      blocks: [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*Test Failures Detected*\\n\\nRepository: ${this.githubRepository}\\nBuild: #${this.githubRunId}\\nFailed Tests: ${report.summary.failedTests}`
          }
        },
        {
          type: 'actions',
          elements: [
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'View Build'
              },
              url: `https://github.com/${this.githubRepository}/actions/runs/${this.githubRunId}`
            }
          ]
        }
      ]
    };

    // In a real implementation, you would send this to Slack
    console.log('Slack notification would be sent:');
    console.log(JSON.stringify(message, null, 2));
    
    // Save Slack message to file for manual review
    const slackFile = path.join(this.coverageDir, `slack-notification-${Date.now()}.json`);
    fs.writeFileSync(slackFile, JSON.stringify(message, null, 2));
    console.log(`Slack notification content saved to: ${slackFile}`);
  }

  /**
   * Send email notification (placeholder)
   */
  async sendEmailNotification(report) {
    const emailRecipients = process.env.TEST_FAILURE_EMAIL_RECIPIENTS;
    
    if (!emailRecipients) {
      console.log('Email recipients not configured. Skipping email notification.');
      return;
    }

    const subject = `Test Failures in ${this.githubRepository} - Build #${this.githubRunId}`;
    const body = this.generateNotificationMessage(report);

    // In a real implementation, you would send this via email service
    console.log('Email notification would be sent:');
    console.log(`To: ${emailRecipients}`);
    console.log(`Subject: ${subject}`);
    console.log(`Body: ${body.substring(0, 200)}...`);
    
    // Save email content to file for manual review
    const emailFile = path.join(this.coverageDir, `email-notification-${Date.now()}.md`);
    fs.writeFileSync(emailFile, `Subject: ${subject}\\n\\n${body}`);
    console.log(`Email notification content saved to: ${emailFile}`);
  }

  /**
   * Run the notifier
   */
  async run() {
    console.log('ðŸ“¢ Running test failure notification system...');
    
    // Ensure coverage directory exists
    if (!fs.existsSync(this.coverageDir)) {
      console.log('Coverage directory not found. No notifications to send.');
      return;
    }

    const report = this.loadTestFailureReport();
    if (!report) {
      console.log('No test failure report found. No notifications to send.');
      return;
    }

    // Only send notifications if there are failures
    if (report.summary.failedTests === 0) {
      console.log('âœ… All tests passed. No failure notifications needed.');
      return;
    }

    console.log(`âŒ ${report.summary.failedTests} test failures detected. Sending notifications...`);

    try {
      // Send various types of notifications
      await this.createGitHubIssue(report);
      await this.updatePullRequestComment(report);
      await this.sendSlackNotification(report);
      await this.sendEmailNotification(report);
      
      console.log('âœ… Notifications sent successfully.');
    } catch (error) {
      console.error(`âŒ Error sending notifications: ${error.message}`);
      process.exit(1);
    }
  }
}

// Run the notifier if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  const notifier = new TestFailureNotifier();
  notifier.run().catch(error => {
    console.error('Fatal error:', error);
    process.exit(1);
  });
}

export default TestFailureNotifier;